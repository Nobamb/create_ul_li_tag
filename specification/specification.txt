### HTML 리스트(`<ul>`, `<li>`) 생성 로직 진화 가이드

---

### 1단계: 하드코딩 (Hardcoding)

데이터와 태그 구조가 완전히 유착되어 있는 가장 원시적인 형태입니다. 반복되는 부분까지 일일이 손으로 작성합니다.

```python
# 1단계: 직접 문자열 더하기
# 데이터: 피카츄, 라이츄, 파이리
# 목표: <ul><li>피카츄</li><li>라이츄</li><li>파이리</li></ul>

start_ul = "<ul>"
end_ul = "</ul>"
start_li = "<li>"
end_li = "</li>"

# 모든 데이터를 직접 태그와 결합
result = start_ul + start_li + "피카츄" + end_li + start_li + "라이츄" + end_li + start_li + "파이리" + end_li + end_ul

print(result)
```

#### 기초 문법 해설

- **변수 할당**: `start_ul = "<ul>"`은 `start_ul`이라는 이름표가 붙은 상자에 `"<ul>"`이라는 글자 조각을 담는 것입니다.
- **문자열 덧셈**: `+` 기호는 숫자 계산이 아니라, 앞 글자와 뒷 글자를 딱풀처럼 이어 붙이는 역할을 합니다.

#### 논리적 설계 이유

논리적인 구조나 규칙을 생각하기보다, 당장 눈앞에 필요한 결과물 텍스트를 가장 직관적으로 조립하는 데 집중했습니다. 데이터가 3개뿐이라 가능했지만, 100개라면 불가능한 방식입니다.

#### 현업 실무 관점

- **하드코딩(Hardcoding)**: 데이터가 코드 로직 속에 딱딱하게 굳어 박혀있는 상태입니다. 포켓몬 이름이 바뀌거나 늘어나면 코드 전체를 뜯어고쳐야 하므로 유지보수 최악의 단계입니다.

---

### 2단계: 함수화 (Basic Function)

반복되는 패턴(`<li>...</li>`)을 처리하기 위해 반복문을 도입하고, 이를 함수로 묶습니다. 하지만 데이터는 아직 함수 외부에 의존적입니다.

```python
# 2단계: 반복문과 전역 변수 사용

	pokemons = ["피카츄", "라이츄", "파이리", "꼬부기"]  # 데이터 리스트

def create_list():
    html_out = "<ul>"  # 시작 태그

    # 리스트에 있는 개수만큼 반복
    for name in pokemons:
        html_out = html_out + "<li>" + name + "</li>"

    html_out = html_out + "</ul>"  # 끝 태그
    return html_out

print(create_list())
```

#### 기초 문법 해설

- **리스트(List)**: `["피카츄", ...]`는 여러 개의 데이터를 순서대로 담는 기차 칸과 같습니다.
- **for 반복문**: `for name in pokemons:`는 포켓몬 기차의 칸을 하나씩 확인하며 그 안의 내용물을 `name`이라는 임시 변수에 담아 아래 코드를 실행하라는 뜻입니다.

#### 논리적 설계 이유

1단계에서는 데이터를 일일이 적었지만, 데이터의 개수가 변할 수 있다는 점을 고려하여 `for` 반복문을 사용했습니다. 이제 데이터가 100개가 되어도 코드는 늘어나지 않습니다.

#### 현업 실무 관점

- **절차적 처리(Procedural)**: 위에서 아래로 순서대로 실행되며 반복 작업을 자동화했습니다.
- 하지만 함수가 외부의 `pokemons`라는 변수에 의존하고 있어, 다른 데이터를 처리하려면 함수를 또 만들어야 하는 단점이 있습니다.

---

### 3단계: 스코프 분리 (Local Scope)

함수가 외부 변수(전역 변수)에 의존하지 않도록, 데이터까지 함수 내부로 가져와 독립성을 확보합니다.

```python
# 3단계: 함수 내부에서 데이터 관리 (지역 변수)

def make_pokemon_html():
    # 데이터를 함수 안으로 숨김 (지역 변수화)
    data = ["피카츄", "라이츄", "파이리"]
    result = "<ul>"

    for item in data:
        # 복합 할당 연산자 사용 (+=)
        result += "<li>" + item + "</li>"

    result += "</ul>"
    return result

print(make_pokemon_html())
```

#### 기초 문법 해설

- **지역 변수**: `data` 변수는 이제 함수 안에서만 존재합니다. 함수 밖에서는 이 변수가 무엇인지 알 수 없습니다. 이를 *변수의 유효 범위(Scope)*라고 합니다.
- **복합 할당 연산자(`+=`)**: `result = result + ...`를 줄여 쓴 것입니다. “기존 내용에 이것을 더해서 저장해라”라는 뜻입니다.

#### 논리적 설계 이유

이전 단계의 코드는 외부 변수 `pokemons`가 없으면 에러가 났습니다. 코드를 안전하게 만들기 위해 필요한 모든 재료를 함수 내부로 옮겨, 함수가 혼자서도 동작할 수 있게 만들었습니다.

#### 현업 실무 관점

- **캡슐화(Encapsulation)의 기초**: 관련된 데이터와 로직을 한곳에 묶어 외부의 간섭을 차단했습니다.
- 하지만, “포켓몬”만 만들 수 있는 함수가 되어 재사용성은 여전히 낮습니다.

---

### 4단계: 매개변수화 (Parameterization)

함수가 오직 “포켓몬”만 만드는 한계를 극복하기 위해, 데이터를 외부에서 주입받도록 입력 구멍(매개변수)을 뚫어줍니다.

```python
# 4단계: 어떤 리스트든 HTML로 만드는 범용 함수

def generate_html_list(items):  # items라는 구멍(매개변수)을 뚫음
    output = "<ul>"

    for item in items:
        output += "<li>" + str(item) + "</li>"  # 숫자가 들어올 경우를 대비해 문자로 변환

    output += "</ul>"
    return output

my_pokemons = ["피카츄", "라이츄"]
my_digimons = ["아구몬", "파피몬"]

print(generate_html_list(my_pokemons))  # 포켓몬 리스트 생성
print(generate_html_list(my_digimons))  # 디지몬 리스트 생성
```

#### 기초 문법 해설

- **매개변수(Parameter)**: `(items)`는 함수가 실행될 때 외부에서 값을 받아오는 출입구입니다. 자판기의 동전 투입구와 같습니다.
- **형 변환 `str()`**: 만약 리스트에 숫자나 다른 형태가 들어있을 수 있으므로, 안전하게 문자열(글자)로 바꿔주는 안전장치입니다.

#### 논리적 설계 이유

3단계 함수는 “포켓몬 생성기”였지만, 이번 단계는 “리스트 생성기”로 진화했습니다. 내용물이 포켓몬이든 디지몬이든 상관없이 동작하므로 코드의 활용도가 비약적으로 상승했습니다.

#### 현업 실무 관점

- **재사용성(Reusability)**: 하나의 로직으로 다양한 상황에 대응할 수 있게 되었습니다. 개발자는 똑같은 코드를 여러 번 짜지 않고, 이 함수 하나를 계속 불러와서 사용합니다.

---

### 5단계: 추상화 (Abstraction)

내부의 복잡한 조립 과정(`<ul>`, `<li>` 문자열 결합 등)을 더 작은 단위로 쪼개고, 사용자는 단순히 “리스트를 만들어줘”라고 요청하면 내부적으로 알아서 조립되도록 구조화합니다.

```python
# 5단계: 역할 분담과 구조화

# 1. 개별 아이템(li)을 만드는 작은 도구 함수
def create_li_tag(content):
    return f"<li>{content}</li>"

# 2. 전체 목록(ul)을 조립하는 메인 함수
def create_ul_component(data_list):
	    # 리스트가 비어있을 경우 예외 처리
    if not data_list:
        return ""

    list_items = []
    for data in data_list:
        # 작은 도구 함수를 사용하여 조립
        tag = create_li_tag(data)
        list_items.append(tag)

    # 리스트에 담긴 문자열들을 줄바꿈 문자(\n)로 예쁘게 연결
    body = "\n".join(list_items)

    return f"<ul>\n{body}\n</ul>"

# 사용
pokes = ["피카츄", "라이츄", "파이리"]
final_html = create_ul_component(pokes)
print(final_html)
```

#### 기초 문법 해설

- **f-string**: `f"<li>{content}</li>"`는 문자열 안에 변수를 직접 끼워 넣는 최신 방식입니다. `+` 기호보다 훨씬 읽기 쉽습니다.
- **`join()`**: 리스트에 담긴 여러 글자 조각들을 특정 문자(여기서는 줄바꿈 `\n`)를 사이에 두고 하나로 합치는 강력한 접착제입니다.

#### 논리적 설계 이유

이전 단계에서는 하나의 함수가 `<ul>`도 만들고 `<li>`도 만들었습니다. 5단계에서는 `<li>`를 만드는 로직을 별도로 분리했습니다. 만약 나중에 `<li>`에 클래스를 추가해야 한다면, `create_li_tag` 함수만 수정하면 됩니다. 전체 로직이 서로 영향을 덜 주게 됩니다.

#### 현업 실무 관점

- **관심사의 분리(Separation of Concerns)**: 각 함수가 하나의 역할에만 집중하게 합니다.
- 또한, 빈 리스트가 들어왔을 때 빈 문자열을 반환하는 등의 **예외 처리**를 추가하여 코드가 실제 서비스에서 안전하게 돌아가도록(Robustness) 보강했습니다. 이것이 실제 라이브러리나 프레임워크가 동작하는 방식과 가장 유사합니다.